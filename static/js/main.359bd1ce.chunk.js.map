{"version":3,"sources":["logo.svg","components/Vertex.js","components/Edge.js","components/Frame.js","components/Graph.js","components/Layout.js","components/utils.js","pages/kruskal.js","pages/home.js","pages/bfs.js","pages/dfs.js","pages/prim.js","pages/dijkstra.js","pages/routes.js","App.js","reportWebVitals.js","index.js"],"names":["INF","Number","MAX_SAFE_INTEGER","COLOR","Vertex","x","y","color","num","this","d","radius","Edge","v1","v2","weight","x1","x2","y1","y2","Frame","vertexCount","edgeCount","vertexesCount","vertexesColor","Array","edgesColor","distance","instruction","execution","i","Graph","n","mat","visited","dist","j","prototype","drawVertex","context","save","beginPath","arc","closePath","fillStyle","fill","font","textAlign","textBaseline","fillText","restore","drawEdge","moveTo","lineTo","strokeStyle","stroke","record","recordDistance","insert","edges","forEach","value","index","array","Layout","children","Container","fluid","Navbar","expand","variant","bg","Brand","Row","Col","md","ListGroup","Item","action","to","style","textDecoration","dfs","v","stack","push","length","top","flag","pop","canvasWidth","canvasHeight","Kruskal","useState","setInstruction","setExecution","vertexes","setVertexes","setEdges","animation","count","isDown","dragTarget","dragEdge","startX","startY","ctx","canvas","useRef","edge","vertexe1","vertexe2","useEffect","canvasEle","current","width","height","getContext","clearRect","draw","drawFrame","handleMouseUp","e","kEdge","begin","end","find","parent","getEdge","ButtonGroup","Button","onClick","event","newVertex","Math","random","DropdownButton","as","title","placeholder","onChange","target","Dropdown","connected","floor","k","graph","frame","m","execution_","instruction_","kEdges","sort","e1","e2","v1Color","v2Color","timer","setInterval","clearInterval","animate","className","ref","onMouseDown","parseInt","nativeEvent","offsetX","clientLeft","offsetY","clientTop","isTarget","circle","sqrt","pow","containsPoint","onMouseMove","mouseX","mouseY","dx","dy","onMouseUp","onMouseOut","type","min","defaultValue","id","onInput","max","dangerouslySetInnerHTML","__html","HomePage","BFS","sourcePoint","queue","result","head","join","headColor","shift","DFS","topColor","Prim","minEdges","minDist","minVertex","Dijkstra","path","temp","TheRoutes","element","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.359bd1ce.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/logo.6ce24c58.svg\";","import React from 'react';\r\n\r\nexport const INF = Number.MAX_SAFE_INTEGER\r\n\r\n\r\nexport const COLOR = {\r\n    PINK: '#eaa0bd',\r\n    GREY: '#383e3e',\r\n    YELLOW: '#eef386',\r\n    BLUE: '#5897ff',\r\n    GREEN: '#6caa52',\r\n    RED: '#e73688'\r\n}\r\n\r\n\r\nexport function Vertex(x, y, color, num) {\r\n    this.x = x\r\n    this.y = y\r\n    this.num = num\r\n    this.color = color\r\n    this.d = -1\r\n    this.radius = 20\r\n}\r\n\r\nVertex.prototype.drawVertex = function (context) {\r\n    context.save()\r\n    context.beginPath()\r\n    context.arc(this.x, this.y, this.radius, 0, 360)\r\n    context.closePath()\r\n\r\n    context.fillStyle = this.color\r\n    context.fill()\r\n\r\n    context.fillStyle = \"black\"\r\n    context.font = \"25px serif\"\r\n    context.textAlign = \"center\"\r\n    context.textBaseline = \"middle\"\r\n    context.fillText(this.num, this.x, this.y)\r\n    context.font = \"20px serif\"\r\n    if(this.d != -1){\r\n        if (this.d == INF)\r\n            context.fillText(\"âˆž\", this.x + 20, this.y + 20)\r\n        else\r\n            context.fillText(this.d, this.x + 20, this.y + 20)\r\n    }\r\n    context.restore()\r\n}","import React from 'react';\r\n\r\nexport function Edge(v1, v2, weight, color) {\r\n    this.v1 = v1.num\r\n    this.v2 = v2.num\r\n    this.x1 = v1.x\r\n    this.x2 = v2.x\r\n    this.y1 = v1.y\r\n    this.y2 = v2.y\r\n    this.weight = weight\r\n    this.color = color\r\n}\r\nEdge.prototype.drawEdge = function(context) {\r\n    context.save()\r\n    context.beginPath()\r\n    context.moveTo(this.x1,this.y1)\r\n    context.lineTo(this.x2,this.y2)\r\n    context.closePath()\r\n    context.strokeStyle = this.color\r\n    context.stroke()\r\n    let x = (this.x1+this.x2)/2\r\n    let y = (this.y1+this.y2)/2\r\n    context.fillStyle = \"black\"\r\n    context.font = \"20px serif\"\r\n    context.textAlign = \"left\"\r\n    context.textBaseline = \"alphabetic\"\r\n    context.fillText(this.weight,x,y)\r\n    context.restore()\r\n}","import React from 'react';\r\nimport {COLOR} from \"./Vertex\";\r\n\r\nexport function Frame(vertexCount, edgeCount) {\r\n    this.vertexesCount = vertexCount\r\n    this.edgeCount = edgeCount\r\n    this.vertexesColor = new Array(vertexCount)\r\n    this.edgesColor = new Array(edgeCount)\r\n    this.distance = new Array(vertexCount)\r\n    this.instruction = \" \"\r\n    this.execution = \"<br>\"\r\n    for(let i = 0; i < vertexCount; i++) {\r\n        this.vertexesColor[i] = COLOR.PINK\r\n    }\r\n    for(let i = 0; i < edgeCount; i++) {\r\n        this.edgesColor[i] = COLOR.GREY\r\n    }\r\n    for(let i = 0; i < vertexCount; i++) {\r\n        this.distance[i] = -1\r\n    }\r\n}\r\nFrame.prototype.record = function (vertexesColor,edgesColor,instruction,execution) {\r\n    for(let i = 0; i < this.vertexesCount; i++) {\r\n        this.vertexesColor[i] = vertexesColor[i]\r\n    }\r\n    for(let i = 0; i < this.edgeCount; i++) {\r\n        this.edgesColor[i] = edgesColor[i]\r\n    }\r\n    this.instruction = instruction\r\n    this.execution = execution\r\n}\r\nFrame.prototype.recordDistance = function (distance) {\r\n    for(let i = 0; i < this.vertexesCount; i++) {\r\n        this.distance[i] = distance[i]\r\n    }\r\n}\r\n","import React from 'react';\r\nimport {INF} from './Vertex';\r\n\r\nexport function Graph(n) {\r\n    this.mat = new Array(n)\r\n    this.visited = new Array(n)\r\n    this.dist = new Array(n)\r\n    this.n = n\r\n    for(let i = 0; i < n; i++) {\r\n        this.mat[i] = new Array(n)\r\n        for(let j = 0; j < n; j++) {\r\n            this.mat[i][j] = INF\r\n        }\r\n    }\r\n    for(let i = 0; i < n; i++) {\r\n        this.visited[i] = 0\r\n        this.dist[i] = INF\r\n    }\r\n}\r\n\r\nGraph.prototype.insert = function (edges) {\r\n    edges.forEach((value,index,array)=>{\r\n        let x = array[index].v1\r\n        let y = array[index].v2\r\n        let weight = array[index].weight\r\n        this.mat[x][y] = weight\r\n        this.mat[y][x] = weight\r\n    })\r\n}\r\n","import React from \"react\";\r\nimport {ListGroup, ListGroupItem} from \"react-bootstrap\";\r\nimport {Container,Row,Col,Navbar} from \"react-bootstrap\";\r\nimport {Link} from \"react-router-dom\";\r\n\r\nexport const Layout = ({ children }) => {\r\n    return (\r\n\r\n        <Container fluid>\r\n                <Navbar expand=\"lg\" variant=\"light\" bg=\"light\">\r\n                    <Container>\r\n                        <Navbar.Brand >Graph Algorithm Visualizer</Navbar.Brand>\r\n                    </Container>\r\n                </Navbar>\r\n            <Row>\r\n                <Col md={2}>\r\n                    <ListGroup variant=\"flush\">\r\n                        <ListGroup.Item action variant=\"secondary\">\r\n                            <Link to=\"/\" style={{color:'black',textDecoration:'none'}}> Home </Link>\r\n                        </ListGroup.Item>\r\n                        <ListGroup.Item>\r\n                            <Link to=\"/bfs\" style={{color:'black',textDecoration:'none'}}> Breadth-first search </Link>\r\n                        </ListGroup.Item>\r\n                        <ListGroup.Item>\r\n                            <Link to=\"/dfs\" style={{color:'black',textDecoration:'none'}}> Depth-first search </Link>\r\n                        </ListGroup.Item>\r\n                        <ListGroup.Item>\r\n                            <Link to=\"/dijkstra\" style={{color:'black',textDecoration:'none'}}> Dijkstra's algorithm </Link>\r\n                        </ListGroup.Item>\r\n                        <ListGroup.Item>\r\n                            <Link to=\"/kruskal\" style={{color:'black',textDecoration:'none'}}> Kruskal's algorithm </Link>\r\n                        </ListGroup.Item>\r\n                        <ListGroup.Item>\r\n                            <Link to=\"/prim\" style={{color:'black',textDecoration:'none'}}> Prim's algorithm </Link>\r\n                        </ListGroup.Item>\r\n\r\n\r\n                    </ListGroup>\r\n                </Col>\r\n                <Col md={10}>{children}</Col>\r\n\r\n            </Row>\r\n        </Container>\r\n    );\r\n};","import React from 'react';\r\nimport {INF} from './Vertex'\r\nexport function dfs(v,visited,mat,n) {\r\n    let stack = []\r\n    stack.push(v)\r\n    visited[v] = 1\r\n    while(stack.length != 0) {\r\n        let top = stack[stack.length-1]\r\n        let flag = 0\r\n        for(let i = 0; i < n; i++) {\r\n            if((mat[top][i]!=INF && visited[i]) || mat[top][i]==INF) {\r\n                flag++\r\n            }\r\n        }\r\n        if(flag == n) {\r\n            stack.pop()\r\n            if(stack.length!=0) top = stack[stack.length-1]\r\n        }\r\n        for(let i = 0; i < n; i++) {\r\n            if(!visited[i] && mat[top][i] != INF) {\r\n                stack.push(i)\r\n                visited[i] = 1\r\n                break\r\n            }\r\n        }\r\n    }\r\n    for(let i = 0; i < n; i++) {\r\n        if(!visited[i]) return 0\r\n    }\r\n    return 1\r\n}\r\n","import React, {useEffect, useRef, useState} from \"react\";\r\nimport {Vertex} from \"../components/Vertex\";\r\nimport {Edge} from \"../components/Edge\";\r\nimport {Frame} from \"../components/Frame\";\r\nimport {Graph} from \"../components/Graph\";\r\nimport {COLOR} from \"../components/Vertex\";\r\nimport {INF} from \"../components/Vertex\";\r\nimport {Layout} from \"../components/Layout\";\r\nimport {ButtonGroup, Button, Dropdown, DropdownButton, Container,Row,Col} from \"react-bootstrap\";\r\nimport {dfs} from \"../components/utils\";\r\n\r\nexport const canvasWidth = 600;\r\nexport const canvasHeight = 300;\r\n\r\nconst Kruskal = () => {\r\n    const [instruction, setInstruction] = useState(\" \");\r\n    const [execution, setExecution] = useState(\" \");\r\n    const [vertexes, setVertexes] = useState([]);\r\n    const [edges, setEdges] = useState([]);\r\n    const [animation,setAnimation] = useState([]);\r\n    let count = 0;\r\n    let isDown = false;\r\n    let dragTarget = null;\r\n    let dragEdge = [];\r\n    let startX = null;\r\n    let startY = null;\r\n    let ctx = null;\r\n    /*let vertexes = [];\r\n    let edges = [];*/\r\n    let randX = canvasWidth - 200\r\n    let randY = canvasHeight - 200\r\n    const canvas = useRef(null);\r\n    let edge = {vertexe1:null, vertexe2:null, weight:null}\r\n\r\n    useEffect(()=>{\r\n        const canvasEle = canvas.current;\r\n        canvasEle.width = canvasWidth;\r\n        canvasEle.height = canvasHeight;\r\n\r\n        // get context of the canvas\r\n        ctx = canvasEle.getContext(\"2d\");\r\n        ctx.clearRect( 0,0, canvasWidth, canvasHeight );\r\n        edges.forEach((value, index, array)=>{array[index].drawEdge(ctx)});\r\n        vertexes.forEach((value, index, array)=>{array[index].drawVertex(ctx)});\r\n\r\n    });\r\n\r\n/*    useEffect(() => {\r\n        draw();\r\n    }, []);*/\r\n\r\n    const draw = () => {\r\n        ctx.clearRect( 0,0, canvasWidth, canvasHeight );\r\n        edges.forEach((value, index, array)=>{array[index].drawEdge(ctx)});\r\n        vertexes.forEach((value, index, array)=>{array[index].drawVertex(ctx)});\r\n\r\n    }\r\n    let drawFrame = function (i,animation) {\r\n        animation[i].edgesColor.forEach((value, index, array)=>{\r\n            edges[index].color = value\r\n        })\r\n        animation[i].vertexesColor.forEach((value, index, array)=>{\r\n            vertexes[index].color = value\r\n        })\r\n        animation[i].distance.forEach((value, index, array)=>{\r\n            vertexes[index].d = value\r\n        })\r\n        setInstruction(animation[i].instruction);\r\n        setExecution(animation[i].execution);\r\n        setVertexes(vertexes);\r\n        setEdges(edges);\r\n        ctx.clearRect( 0,0, canvasWidth, canvasHeight );\r\n        edges.forEach((value, index, array)=>{array[index].drawEdge(ctx)});\r\n        vertexes.forEach((value, index, array)=>{array[index].drawVertex(ctx)});\r\n\r\n    }\r\n\r\n    function animate(animation) {\r\n        let index = 0;\r\n        let timer = setInterval(frame, 500)\r\n        function frame() {\r\n            if (index == animation.length) {\r\n                clearInterval(timer)\r\n            } else {\r\n                drawFrame(index,animation)\r\n                //draw()\r\n                index++\r\n            }\r\n        }\r\n    }\r\n\r\n    const containsPoint = (x, y) => {\r\n        let isTarget = null;\r\n        for (let i = 0; i < vertexes.length; i++) {\r\n            const circle = vertexes[i];\r\n            let distance = Math.sqrt(Math.pow((circle.x-x),2)+Math.pow((circle.y-y),2))\r\n            if(distance < circle.radius*3/2) {\r\n                dragTarget = circle;\r\n                for(let j = 0; j < edges.length; j++) {\r\n                    if(edges[j].v1 == dragTarget.num)\r\n                        dragEdge.push({num: j, v: 1});\r\n                    if(edges[j].v2 == dragTarget.num)\r\n                        dragEdge.push({num: j, v: 2});\r\n                }\r\n                isTarget = true;\r\n                break;\r\n            }\r\n        }\r\n        return isTarget;\r\n    }\r\n\r\n    const handleCanvasClick=(event)=>{\r\n        const X = Math.random()*(randX)+100;\r\n        const Y = Math.random()*(randY)+100;\r\n        const newVertex = new Vertex(X,Y,COLOR.PINK,vertexes.length)\r\n        vertexes.push(newVertex);\r\n        draw();\r\n    };\r\n\r\n    const handleMouseMove = (event)=>{\r\n        if (!isDown) return;\r\n        const mouseX = parseInt(event.nativeEvent.offsetX - canvas.current.clientLeft);\r\n        const mouseY = parseInt(event.nativeEvent.offsetY - canvas.current.clientTop);\r\n        const dx = mouseX - startX;\r\n        const dy = mouseY - startY;\r\n        startX = mouseX;\r\n        startY = mouseY;\r\n        dragTarget.x += dx;\r\n        dragTarget.y += dy;\r\n        if(dragEdge.length != 0){\r\n            for(let i = 0; i < dragEdge.length; i++) {\r\n                if (dragEdge[i].v == 1) {\r\n                    edges[dragEdge[i].num].x1 += dx;\r\n                    edges[dragEdge[i].num].y1 += dy;\r\n                }\r\n                if (dragEdge[i].v == 2) {\r\n                    edges[dragEdge[i].num].x2 += dx;\r\n                    edges[dragEdge[i].num].y2 += dy;\r\n                }\r\n            }\r\n        }\r\n        draw();\r\n    };\r\n\r\n    const handleMouseDown = (event)=>{\r\n        startX = parseInt(event.nativeEvent.offsetX - canvas.current.clientLeft);\r\n        startY = parseInt(event.nativeEvent.offsetY - canvas.current.clientTop);\r\n        isDown = containsPoint(startX,startY)\r\n    };\r\n\r\n    const handleMouseUp = e => {\r\n        dragTarget = null;\r\n        dragEdge = [];\r\n        isDown = false;\r\n    }\r\n    const handleMouseOut = e => {\r\n        handleMouseUp(e);\r\n    }\r\n\r\n    const handleClearCanvas=(event)=>{\r\n        setVertexes([]);\r\n        setEdges([]);\r\n        setExecution(\" \");\r\n        setInstruction(\" \");\r\n    };\r\n\r\n    const inputChange1=(event)=>{\r\n        edge.vertexe1 = event.target.value;\r\n    };\r\n    const inputChange2=(event)=>{\r\n        edge.vertexe2 = event.target.value;\r\n    };\r\n    const inputChange3=(event)=>{\r\n        edge.weight = event.target.value;\r\n    };\r\n    const inputChange4=(event)=>{\r\n        count = event.target.value;\r\n    };\r\n    const sliderChange=(event)=>{\r\n        if(animation.length > 0) {\r\n            event.target.max = animation.length - 1;\r\n            drawFrame(event.target.value,animation);\r\n        }\r\n    };\r\n    const handleGraphClick = (event)=>{\r\n        for(let i = 0; i < count; i++) {\r\n            vertexes.push(new Vertex(Math.random()*(randX)+100,Math.random()*(randY)+100,COLOR.PINK,vertexes.length))\r\n        }\r\n        let connected = 0\r\n        while(!connected) {\r\n            let flag = 1\r\n            for(let j = 0; j < Math.floor(Math.random()*(vertexes.length*5)); j++) {\r\n                let v1 = Math.floor(Math.random()*vertexes.length)\r\n                let v2 = Math.floor(Math.random()*vertexes.length)\r\n                let weight = Math.floor(Math.random()*100+1)\r\n                for(let k = 0; k < edges.length; k++) {\r\n                    if ((edges[k].v1 == v1 || edges[k].v1 == v2)\r\n                        && (edges[k].v2 == v1 || edges[k].v2 == v2)) {\r\n                        flag = 0\r\n                        break\r\n                    }\r\n                }\r\n                if(!(v1 == v2) && flag){\r\n                    edges.push(new Edge(vertexes[v1], vertexes[v2], weight, COLOR.GREY))\r\n                }\r\n            }\r\n            let graph = new Graph(vertexes.length)\r\n            graph.insert(edges)\r\n            connected = dfs(0,graph.visited,graph.mat,graph.n)\r\n        }\r\n        draw()\r\n    }\r\n    const handleEdgeClick = (event)=>{\r\n        let v1 = edge.vertexe1;\r\n        let v2 = edge.vertexe2;\r\n        let weight = edge.weight;\r\n        edges.push(new Edge(vertexes[v1], vertexes[v2], weight, COLOR.GREY))\r\n        draw();\r\n    };\r\n    function kEdge() {\r\n        this.begin = 0\r\n        this.end = 0\r\n        this.weight = 0\r\n    }\r\n    function find(parent, n) {\r\n        while(parent[n] > 0) {\r\n            n = parent[n]\r\n        }\r\n        return n\r\n    }\r\n    let getEdge = function (v1,v2,edges) {\r\n        let num\r\n        edges.forEach((value, index, array)=>{\r\n            if((array[index].v1 == v1 || array[index].v1 == v2)\r\n                && (array[index].v2 == v1 || array[index].v2 == v2)) {\r\n                num = index\r\n            }\r\n        })\r\n        return num\r\n    }\r\n\r\n    const kruskal = ()=>{\r\n        let frame\r\n        let execution_ = \"<br>\"\r\n        let instruction_ = \"Edges: \"\r\n\r\n        let n, m\r\n        let graph = new Graph(vertexes.length)\r\n        let parent = []\r\n        let vertexesColor = new Array(vertexes.length)\r\n        let edgesColor = new Array(edges.length)\r\n        for(let i = 0; i < vertexes.length; i++) {\r\n            vertexesColor[i] = COLOR.PINK\r\n        }\r\n        for(let i = 0; i < edges.length; i++) {\r\n            edgesColor[i] = COLOR.GREY\r\n        }\r\n        graph.insert(edges)\r\n/*        if(graph.n < 2) {\r\n            alert(\"Graph does not exist\")\r\n            return\r\n        }\r\n        let connected = utils.dfs(0,graph.visited,graph.mat,graph.n)\r\n        if(!connected) {\r\n            alert(\"Graph is not connected\")\r\n            return\r\n        }\r\n        disableButtons()*/\r\n        animation.push(new Frame(vertexes.length,edges.length))\r\n        let kEdges = []\r\n        for(let i = 0; i < graph.n; i++) {\r\n            parent[i] = 0\r\n        }\r\n        for(let i = 0; i < graph.n; i++) {\r\n            for(let j = i; j < graph.n; j++) {\r\n                if(graph.mat[i][j] < INF) {\r\n                    let edge = new kEdge();\r\n                    edge.begin = i\r\n                    edge.end = j\r\n                    edge.weight = graph.mat[i][j]\r\n                    kEdges.push(edge)\r\n                }\r\n            }\r\n        }\r\n        kEdges.sort((e1,e2)=>{\r\n            return e1.weight - e2.weight\r\n        })\r\n\r\n        execution_ += \"Sort edges by increasing weight<br/><br/>\"\r\n\r\n        for(let i = 0; i < kEdges.length; i++) {\r\n            n = find(parent,kEdges[i].begin)\r\n            m = find(parent,kEdges[i].end)\r\n\r\n            let v1Color = vertexesColor[kEdges[i].begin]\r\n            let v2Color = vertexesColor[kEdges[i].end]\r\n            vertexesColor[kEdges[i].begin] = COLOR.YELLOW\r\n            vertexesColor[kEdges[i].end] = COLOR.YELLOW\r\n            edgesColor[getEdge(kEdges[i].begin,kEdges[i].end,edges)]=COLOR.YELLOW\r\n            execution_ += \"For edge \"+kEdges[i].begin+\"--\"+kEdges[i].end+\"<br/>\"\r\n            frame = new Frame(vertexes.length,edges.length)\r\n            frame.record(vertexesColor,edgesColor,instruction_,execution_)\r\n            animation.push(frame)\r\n\r\n            if(n != m) {\r\n                parent[n] = m\r\n\r\n                edgesColor[getEdge(kEdges[i].begin,kEdges[i].end,edges)]=COLOR.GREEN\r\n                vertexesColor[kEdges[i].begin] = COLOR.GREEN\r\n                vertexesColor[kEdges[i].end] = COLOR.GREEN\r\n                execution_ +=\"Adding edge \"+kEdges[i].begin+\"--\"+kEdges[i].end+\r\n                    \" does not form a cycle <br/> Add edge \"+kEdges[i].begin+\"--\"+kEdges[i].end+\"<br/>\"\r\n                instruction_ += kEdges[i].begin+\"--\"+kEdges[i].end+\" \"\r\n                frame = new Frame(vertexes.length,edges.length)\r\n                frame.record(vertexesColor,edgesColor,instruction_,execution_)\r\n                animation.push(frame)\r\n\r\n            }else {\r\n\r\n                vertexesColor[kEdges[i].begin] = v1Color\r\n                vertexesColor[kEdges[i].end] = v2Color\r\n                edgesColor[getEdge(kEdges[i].begin,kEdges[i].end,edges)]=COLOR.GREY\r\n                execution_ += \"Adding edge \"+kEdges[i].begin+\"--\"+kEdges[i].end+\r\n                    \" will form a cycle<br/>Ignore the edge<br/>\"\r\n                frame = new Frame(vertexes.length,edges.length)\r\n                frame.record(vertexesColor,edgesColor,instruction_,execution_)\r\n                animation.push(frame)\r\n            }\r\n            execution_+=\"<br/>\"\r\n        }\r\n        animate(animation);\r\n    }\r\n\r\n    return (\r\n        <Layout>\r\n                <Row>\r\n                    <Col md={7}>\r\n                        <ButtonGroup aria-label=\"Basic example\">\r\n                            <Button variant=\"secondary\" onClick={handleClearCanvas}>CLEAR</Button>\r\n                            <Button variant=\"secondary\" onClick={handleCanvasClick}>VERTEX</Button>\r\n                            <DropdownButton as={ButtonGroup} title=\"EDGE\" variant=\"secondary\">\r\n                                <input placeholder=\"vertex1\" onChange={inputChange1}/>\r\n                                <input placeholder=\"vertex2\" onChange={inputChange2}/>\r\n                                <input placeholder=\"weight\" onChange={inputChange3}/>\r\n                                <Dropdown.Item onClick={handleEdgeClick}>GENERATE</Dropdown.Item>\r\n                            </DropdownButton>\r\n                            <DropdownButton as={ButtonGroup} title=\"GRAPH\" variant=\"secondary\">\r\n                                <input placeholder=\"count\" onChange={inputChange4}/>\r\n                                <Dropdown.Item onClick={handleGraphClick}>GENERATE</Dropdown.Item>\r\n                            </DropdownButton>\r\n                            <Button variant=\"secondary\" onClick={kruskal}>ANIMATION</Button>\r\n                        </ButtonGroup>\r\n                        <div>\r\n                            <canvas\r\n                                className=\"App-canvas\"\r\n                                ref={canvas}\r\n                                width={canvasWidth}\r\n                                height={canvasHeight}\r\n                                onMouseDown={handleMouseDown}\r\n                                onMouseMove={handleMouseMove}\r\n                                onMouseUp={handleMouseUp}\r\n                                onMouseOut={handleMouseOut}/>\r\n                            <div className=\"text-center\">\r\n                                <input type=\"range\" min={0} defaultValue={0} className=\"p-3 slider\" id=\"slider\" onInput={sliderChange}/>\r\n                            </div>\r\n                        </div>\r\n                        <div id=\"instruction\" dangerouslySetInnerHTML={{__html:instruction}}></div>\r\n                        <div id=\"execution\" dangerouslySetInnerHTML={{__html:execution}}></div>\r\n                    </Col>\r\n                    <Col md={5}>\r\n                        <div className=\"bg-secondary bg-opacity-25\">\r\n                            <h3 className=\"text-secondary p-3\">Kruskal's algorithm</h3>\r\n                        </div>\r\n                        <div id=\"code\">\r\n                        <pre>\r\n    {`\r\nfunction kruskal(graph) {\r\n    let n, m\r\n    let parent = []\r\n    let kEdges = []\r\n    for(let i = 0; i < graph.n; i++) {\r\n        parent[i] = 0\r\n    }\r\n    for(let i = 0; i < graph.n; i++) {\r\n        for(let j = i; j < graph.n; j++) {\r\n            if(graph.mat[i][j] < INF) {\r\n                let edge = new kEdge();\r\n                edge.begin = i\r\n                edge.end = j\r\n                edge.weight = graph.mat[i][j]\r\n                kEdges.push(edge)\r\n            }\r\n        }\r\n    }\r\n    kEdges.sort((e1,e2)=>{\r\n        return e1.weight - e2.weight\r\n    })\r\n    for(let i = 0; i < kEdges.length; i++) {\r\n        n = find(parent,kEdges[i].begin)\r\n        m = find(parent,kEdges[i].end)\r\n        if(n != m) {\r\n            parent[n] = m\r\n        }\r\n    }\r\n}\r\nfunction kEdge() {\r\n    this.begin = 0\r\n    this.end = 0\r\n    this.weight = 0\r\n}\r\nfunction find(parent, n) {\r\n    while(parent[n] > 0) {\r\n        n = parent[n]\r\n    }\r\n    return n\r\n}\r\n    `}\r\n</pre>\r\n                        </div>\r\n                    </Col>\r\n                </Row>\r\n\r\n        </Layout>\r\n    )\r\n}\r\n\r\nexport default Kruskal;","import React from 'react';\r\nimport {Layout} from \"../components/Layout\";\r\n\r\nconst HomePage = () => {\r\n\r\n    return (\r\n        <Layout></Layout>\r\n    )\r\n}\r\n\r\nexport default HomePage;","import React, {useEffect, useRef, useState} from \"react\";\r\nimport {Vertex} from \"../components/Vertex\";\r\nimport {Edge} from \"../components/Edge\";\r\nimport {Frame} from \"../components/Frame\";\r\nimport {Graph} from \"../components/Graph\";\r\nimport {COLOR} from \"../components/Vertex\";\r\nimport {INF} from \"../components/Vertex\";\r\nimport {Layout} from \"../components/Layout\";\r\nimport {ButtonGroup, Button, Dropdown, DropdownButton, Container,Row,Col} from \"react-bootstrap\";\r\nimport {dfs} from \"../components/utils\";\r\n\r\nexport const canvasWidth = 600;\r\nexport const canvasHeight = 300;\r\n\r\nconst BFS = () => {\r\n    const [instruction, setInstruction] = useState(\" \");\r\n    const [execution, setExecution] = useState(\" \");\r\n    const [vertexes, setVertexes] = useState([]);\r\n    const [edges, setEdges] = useState([]);\r\n    const [animation,setAnimation] = useState([]);\r\n    let sourcePoint = 0;\r\n    let count = 0;\r\n    let isDown = false;\r\n    let dragTarget = null;\r\n    let dragEdge = [];\r\n    let startX = null;\r\n    let startY = null;\r\n    let ctx = null;\r\n    /*let vertexes = [];\r\n    let edges = [];*/\r\n    let randX = canvasWidth - 200\r\n    let randY = canvasHeight - 200\r\n    const canvas = useRef(null);\r\n    let edge = {vertexe1:null, vertexe2:null, weight:null}\r\n\r\n    useEffect(()=>{\r\n        const canvasEle = canvas.current;\r\n        canvasEle.width = canvasWidth;\r\n        canvasEle.height = canvasHeight;\r\n\r\n        // get context of the canvas\r\n        ctx = canvasEle.getContext(\"2d\");\r\n        ctx.clearRect( 0,0, canvasWidth, canvasHeight );\r\n        edges.forEach((value, index, array)=>{array[index].drawEdge(ctx)});\r\n        vertexes.forEach((value, index, array)=>{array[index].drawVertex(ctx)});\r\n\r\n    });\r\n\r\n    /*    useEffect(() => {\r\n            draw();\r\n        }, []);*/\r\n\r\n    const draw = () => {\r\n        ctx.clearRect( 0,0, canvasWidth, canvasHeight );\r\n        edges.forEach((value, index, array)=>{array[index].drawEdge(ctx)});\r\n        vertexes.forEach((value, index, array)=>{array[index].drawVertex(ctx)});\r\n\r\n    }\r\n    let drawFrame = function (i,animation) {\r\n        animation[i].edgesColor.forEach((value, index, array)=>{\r\n            edges[index].color = value\r\n        })\r\n        animation[i].vertexesColor.forEach((value, index, array)=>{\r\n            vertexes[index].color = value\r\n        })\r\n        animation[i].distance.forEach((value, index, array)=>{\r\n            vertexes[index].d = value\r\n        })\r\n        setInstruction(animation[i].instruction);\r\n        setExecution(animation[i].execution);\r\n        setVertexes(vertexes);\r\n        setEdges(edges);\r\n        ctx.clearRect( 0,0, canvasWidth, canvasHeight );\r\n        edges.forEach((value, index, array)=>{array[index].drawEdge(ctx)});\r\n        vertexes.forEach((value, index, array)=>{array[index].drawVertex(ctx)});\r\n\r\n    }\r\n\r\n    function animate(animation) {\r\n        let index = 0;\r\n        let timer = setInterval(frame, 500)\r\n        function frame() {\r\n            if (index == animation.length) {\r\n                clearInterval(timer)\r\n            } else {\r\n                drawFrame(index,animation)\r\n                //draw()\r\n                index++\r\n            }\r\n        }\r\n    }\r\n\r\n    const containsPoint = (x, y) => {\r\n        let isTarget = null;\r\n        for (let i = 0; i < vertexes.length; i++) {\r\n            const circle = vertexes[i];\r\n            let distance = Math.sqrt(Math.pow((circle.x-x),2)+Math.pow((circle.y-y),2))\r\n            if(distance < circle.radius*3/2) {\r\n                dragTarget = circle;\r\n                for(let j = 0; j < edges.length; j++) {\r\n                    if(edges[j].v1 == dragTarget.num)\r\n                        dragEdge.push({num: j, v: 1});\r\n                    if(edges[j].v2 == dragTarget.num)\r\n                        dragEdge.push({num: j, v: 2});\r\n                }\r\n                isTarget = true;\r\n                break;\r\n            }\r\n        }\r\n        return isTarget;\r\n    }\r\n\r\n    const handleCanvasClick=(event)=>{\r\n        const X = Math.random()*(randX)+100;\r\n        const Y = Math.random()*(randY)+100;\r\n        const newVertex = new Vertex(X,Y,COLOR.PINK,vertexes.length)\r\n        vertexes.push(newVertex);\r\n        draw();\r\n    };\r\n\r\n    const handleMouseMove = (event)=>{\r\n        if (!isDown) return;\r\n        const mouseX = parseInt(event.nativeEvent.offsetX - canvas.current.clientLeft);\r\n        const mouseY = parseInt(event.nativeEvent.offsetY - canvas.current.clientTop);\r\n        const dx = mouseX - startX;\r\n        const dy = mouseY - startY;\r\n        startX = mouseX;\r\n        startY = mouseY;\r\n        dragTarget.x += dx;\r\n        dragTarget.y += dy;\r\n        if(dragEdge.length != 0){\r\n            for(let i = 0; i < dragEdge.length; i++) {\r\n                if (dragEdge[i].v == 1) {\r\n                    edges[dragEdge[i].num].x1 += dx;\r\n                    edges[dragEdge[i].num].y1 += dy;\r\n                }\r\n                if (dragEdge[i].v == 2) {\r\n                    edges[dragEdge[i].num].x2 += dx;\r\n                    edges[dragEdge[i].num].y2 += dy;\r\n                }\r\n            }\r\n        }\r\n        draw();\r\n    };\r\n\r\n    const handleMouseDown = (event)=>{\r\n        startX = parseInt(event.nativeEvent.offsetX - canvas.current.clientLeft);\r\n        startY = parseInt(event.nativeEvent.offsetY - canvas.current.clientTop);\r\n        isDown = containsPoint(startX,startY)\r\n    };\r\n\r\n    const handleMouseUp = e => {\r\n        dragTarget = null;\r\n        dragEdge = [];\r\n        isDown = false;\r\n    }\r\n    const handleMouseOut = e => {\r\n        handleMouseUp(e);\r\n    }\r\n\r\n    const handleClearCanvas=(event)=>{\r\n        setVertexes([]);\r\n        setEdges([]);\r\n        setExecution(\" \");\r\n        setInstruction(\" \");\r\n    };\r\n\r\n    const inputChange1=(event)=>{\r\n        edge.vertexe1 = event.target.value;\r\n    };\r\n    const inputChange2=(event)=>{\r\n        edge.vertexe2 = event.target.value;\r\n    };\r\n    const inputChange3=(event)=>{\r\n        edge.weight = event.target.value;\r\n    };\r\n    const inputChange4=(event)=>{\r\n        count = event.target.value;\r\n    };\r\n    const inputSourcePoint=(event)=>{\r\n        sourcePoint = event.target.value;\r\n    };\r\n    const sliderChange=(event)=>{\r\n        if(animation.length > 0) {\r\n            event.target.max = animation.length - 1;\r\n            drawFrame(event.target.value,animation);\r\n        }\r\n    };\r\n    const handleGraphClick = (event)=>{\r\n        for(let i = 0; i < count; i++) {\r\n            vertexes.push(new Vertex(Math.random()*(randX)+100,Math.random()*(randY)+100,COLOR.PINK,vertexes.length))\r\n        }\r\n        let connected = 0\r\n        while(!connected) {\r\n            let flag = 1\r\n            for(let j = 0; j < Math.floor(Math.random()*(vertexes.length*5)); j++) {\r\n                let v1 = Math.floor(Math.random()*vertexes.length)\r\n                let v2 = Math.floor(Math.random()*vertexes.length)\r\n                let weight = Math.floor(Math.random()*100+1)\r\n                for(let k = 0; k < edges.length; k++) {\r\n                    if ((edges[k].v1 == v1 || edges[k].v1 == v2)\r\n                        && (edges[k].v2 == v1 || edges[k].v2 == v2)) {\r\n                        flag = 0\r\n                        break\r\n                    }\r\n                }\r\n                if(!(v1 == v2) && flag){\r\n                    edges.push(new Edge(vertexes[v1], vertexes[v2], weight, COLOR.GREY))\r\n                }\r\n            }\r\n            let graph = new Graph(vertexes.length)\r\n            graph.insert(edges)\r\n            connected = dfs(0,graph.visited,graph.mat,graph.n)\r\n        }\r\n        draw()\r\n    }\r\n    const handleEdgeClick = (event)=>{\r\n        let v1 = edge.vertexe1;\r\n        let v2 = edge.vertexe2;\r\n        let weight = edge.weight;\r\n        edges.push(new Edge(vertexes[v1], vertexes[v2], weight, COLOR.GREY))\r\n        draw();\r\n    };\r\n    function kEdge() {\r\n        this.begin = 0\r\n        this.end = 0\r\n        this.weight = 0\r\n    }\r\n    function find(parent, n) {\r\n        while(parent[n] > 0) {\r\n            n = parent[n]\r\n        }\r\n        return n\r\n    }\r\n    let getEdge = function (v1,v2,edges) {\r\n        let num\r\n        edges.forEach((value, index, array)=>{\r\n            if((array[index].v1 == v1 || array[index].v1 == v2)\r\n                && (array[index].v2 == v1 || array[index].v2 == v2)) {\r\n                num = index\r\n            }\r\n        })\r\n        return num\r\n    }\r\n\r\n    const bfs = ()=>{\r\n        let frame\r\n        let execution = \"<br>\"\r\n        let instruction = \" \"\r\n        let v = sourcePoint;\r\n        let graph = new Graph(vertexes.length)\r\n        let queue = []\r\n        let result = []\r\n/*        if(v<0 || v>=vertexCount || isNaN(v)) {\r\n            alert(\"Vertex does not exist\")\r\n            return\r\n        }\r\n        if(graph.n == 0) {\r\n            alert(\"Graph does not exist\")\r\n            return\r\n        }*/\r\n        //disableButtons()\r\n        animation.push(new Frame(vertexes.length,edges.length))\r\n        let vertexesColor = new Array(vertexes.length)\r\n        let edgesColor = new Array(edges.length)\r\n        for(let i = 0; i < vertexes.length; i++) {\r\n            vertexesColor[i] = COLOR.PINK\r\n        }\r\n        for(let i = 0; i < edges.length; i++) {\r\n            edgesColor[i] = COLOR.GREY\r\n        }\r\n        graph.insert(edges)\r\n        queue.push(v)\r\n        result.push(v)\r\n        graph.visited[v] = 1\r\n        vertexesColor[v] = COLOR.GREEN\r\n        frame = new Frame(vertexes.length,edges.length)\r\n        frame.record(vertexesColor,edgesColor,instruction,execution)\r\n        animation.push(frame)\r\n        while(queue.length != 0) {\r\n            let head = queue[0]\r\n            let flag = 0\r\n            for(let i = 0; i < graph.n; i++) {\r\n                if(!graph.visited[i] && graph.mat[head][i]!=INF) {\r\n                    queue.push(i)\r\n                    instruction = \"queue \"+queue.join(\" | \")\r\n                    graph.visited[i] = 1\r\n                    result.push(i)\r\n                    execution+= i+\" is not visited, \"+\"visit \"+i+\"<br><br>\"\r\n                    vertexesColor[i]=COLOR.GREEN\r\n                    frame = new Frame(vertexes.length,edges.length)\r\n                    frame.record(vertexesColor,edgesColor,instruction,execution)\r\n                    animation.push(frame)\r\n                }\r\n            }\r\n            let headColor = vertexesColor[head]\r\n            vertexesColor[head]=COLOR.RED\r\n            execution += \"visit the adjacent vertexes of \"+head+\"<br>\"\r\n            for(let i = 0; i < graph.n; i++) {\r\n                if((graph.mat[head][i]<INF && graph.visited[i])||graph.mat[head][i]==INF) {\r\n                    flag++\r\n                }\r\n                if(graph.mat[head][i]<INF && graph.visited[i]) {\r\n                    execution += i+\" is visited<br>\"\r\n                    let color = vertexesColor[i]\r\n                    vertexesColor[i] = COLOR.RED\r\n                    edgesColor[getEdge(head,i,edges)] = COLOR.RED\r\n                    frame = new Frame(vertexes.length,edges.length)\r\n                    frame.record(vertexesColor,edgesColor,instruction,execution)\r\n                    animation.push(frame)\r\n\r\n                    vertexesColor[i]=color\r\n                    edgesColor[getEdge(head,i,edges)] = COLOR.GREY\r\n                    frame = new Frame(vertexes.length,edges.length)\r\n                    frame.record(vertexesColor,edgesColor,instruction,execution)\r\n                    animation.push(frame)\r\n                }\r\n            }\r\n            vertexesColor[head] = headColor\r\n            frame = new Frame(vertexes.length,edges.length)\r\n            frame.record(vertexesColor,edgesColor,instruction,execution)\r\n            animation.push(frame)\r\n            if(flag==graph.n) {\r\n                queue.shift()\r\n                instruction = \"queue \"+queue.join(\" | \")\r\n                execution += \"All of the adjacent vertexes of \"+head+\" are visited<br><br>\"\r\n                if(queue.length != 0) head = queue[0]\r\n            }\r\n        }\r\n        instruction = \"visit order: \"+result.join(\" \")\r\n        frame = new Frame(vertexes.length,edges.length)\r\n        frame.record(vertexesColor,edgesColor,instruction,execution)\r\n        animation.push(frame)\r\n        animate(animation);\r\n    }\r\n\r\n    return (\r\n        <Layout>\r\n            <Row>\r\n                <Col md={7}>\r\n                    <ButtonGroup aria-label=\"Basic example\">\r\n                        <Button variant=\"secondary\" onClick={handleClearCanvas}>CLEAR</Button>\r\n                        <Button variant=\"secondary\" onClick={handleCanvasClick}>VERTEX</Button>\r\n                        <DropdownButton as={ButtonGroup} title=\"EDGE\" variant=\"secondary\">\r\n                            <input placeholder=\"vertex1\" onChange={inputChange1}/>\r\n                            <input placeholder=\"vertex2\" onChange={inputChange2}/>\r\n                            <input placeholder=\"weight\" onChange={inputChange3}/>\r\n                            <Dropdown.Item onClick={handleEdgeClick}>GENERATE</Dropdown.Item>\r\n                        </DropdownButton>\r\n                        <DropdownButton as={ButtonGroup} title=\"GRAPH\" variant=\"secondary\">\r\n                            <input placeholder=\"count\" onChange={inputChange4}/>\r\n                            <Dropdown.Item onClick={handleGraphClick}>GENERATE</Dropdown.Item>\r\n                        </DropdownButton>\r\n                        <DropdownButton as={ButtonGroup} title=\"ANIMATION\" variant=\"secondary\">\r\n                            <input placeholder=\"vertex1\" onChange={inputSourcePoint}/>\r\n                            <Dropdown.Item onClick={bfs}>START</Dropdown.Item>\r\n                        </DropdownButton>\r\n                    </ButtonGroup>\r\n                    <div>\r\n                        <canvas\r\n                            className=\"App-canvas\"\r\n                            ref={canvas}\r\n                            width={canvasWidth}\r\n                            height={canvasHeight}\r\n                            onMouseDown={handleMouseDown}\r\n                            onMouseMove={handleMouseMove}\r\n                            onMouseUp={handleMouseUp}\r\n                            onMouseOut={handleMouseOut}/>\r\n                        <div className=\"text-center\">\r\n                            <input type=\"range\" min={0} defaultValue={0} className=\"p-3 slider\" id=\"slider\" onInput={sliderChange}/>\r\n                        </div>\r\n                    </div>\r\n                    <div id=\"instruction\" dangerouslySetInnerHTML={{__html:instruction}}></div>\r\n                    <div id=\"execution\" dangerouslySetInnerHTML={{__html:execution}}></div>\r\n                </Col>\r\n                <Col md={5}>\r\n                    <div className=\"bg-secondary bg-opacity-25\">\r\n                        <h3 className=\"text-secondary p-3\">Breadth-first search</h3>\r\n                    </div>\r\n                    <div id=\"code\">\r\n                        <pre>\r\n    {`\r\nfunction bfs(v,graph) {\r\n    let queue = []\r\n    queue.push(v)\r\n    graph.visited[v] = 1\r\n    while(queue.length != 0) {\r\n        let head = queue[0]\r\n        let flag = 0\r\n        for(let i = 0; i < graph.n; i++) {\r\n            if((graph.mat[head][i] < INF && graph.visited[i]) || graph.mat[head][i] == Infinity) {\r\n                flag++\r\n            }\r\n        }\r\n        if(flag == graph.n) {\r\n            queue.shift()\r\n            if(queue.length != 0) head = queue[0]\r\n        }\r\n        for(let i = 0; i < graph.n; i++) {\r\n            if(!graph.visited[i] && graph.mat[head][i] != Infinity) {\r\n                queue.push(i)\r\n                graph.visited[i] = 1\r\n                break\r\n            }\r\n        }\r\n    }\r\n}\r\n    `}\r\n</pre>\r\n                    </div>\r\n                </Col>\r\n            </Row>\r\n\r\n        </Layout>\r\n    )\r\n}\r\n\r\nexport default BFS;\r\n","import React, {useEffect, useRef, useState} from \"react\";\r\nimport {Vertex} from \"../components/Vertex\";\r\nimport {Edge} from \"../components/Edge\";\r\nimport {Frame} from \"../components/Frame\";\r\nimport {Graph} from \"../components/Graph\";\r\nimport {COLOR} from \"../components/Vertex\";\r\nimport {INF} from \"../components/Vertex\";\r\nimport {Layout} from \"../components/Layout\";\r\nimport {ButtonGroup, Button, Dropdown, DropdownButton, Container,Row,Col} from \"react-bootstrap\";\r\nimport {dfs} from \"../components/utils\";\r\n\r\nexport const canvasWidth = 600;\r\nexport const canvasHeight = 300;\r\n\r\nconst DFS = () => {\r\n    const [instruction, setInstruction] = useState(\" \");\r\n    const [execution, setExecution] = useState(\" \");\r\n    const [vertexes, setVertexes] = useState([]);\r\n    const [edges, setEdges] = useState([]);\r\n    const [animation,setAnimation] = useState([]);\r\n    let sourcePoint = 0;\r\n    let count = 0;\r\n    let isDown = false;\r\n    let dragTarget = null;\r\n    let dragEdge = [];\r\n    let startX = null;\r\n    let startY = null;\r\n    let ctx = null;\r\n    /*let vertexes = [];\r\n    let edges = [];*/\r\n    let randX = canvasWidth - 200\r\n    let randY = canvasHeight - 200\r\n    const canvas = useRef(null);\r\n    let edge = {vertexe1:null, vertexe2:null, weight:null}\r\n\r\n    useEffect(()=>{\r\n        const canvasEle = canvas.current;\r\n        canvasEle.width = canvasWidth;\r\n        canvasEle.height = canvasHeight;\r\n\r\n        // get context of the canvas\r\n        ctx = canvasEle.getContext(\"2d\");\r\n        ctx.clearRect( 0,0, canvasWidth, canvasHeight );\r\n        edges.forEach((value, index, array)=>{array[index].drawEdge(ctx)});\r\n        vertexes.forEach((value, index, array)=>{array[index].drawVertex(ctx)});\r\n\r\n    });\r\n\r\n    /*    useEffect(() => {\r\n            draw();\r\n        }, []);*/\r\n\r\n    const draw = () => {\r\n        ctx.clearRect( 0,0, canvasWidth, canvasHeight );\r\n        edges.forEach((value, index, array)=>{array[index].drawEdge(ctx)});\r\n        vertexes.forEach((value, index, array)=>{array[index].drawVertex(ctx)});\r\n\r\n    }\r\n    let drawFrame = function (i,animation) {\r\n        animation[i].edgesColor.forEach((value, index, array)=>{\r\n            edges[index].color = value\r\n        })\r\n        animation[i].vertexesColor.forEach((value, index, array)=>{\r\n            vertexes[index].color = value\r\n        })\r\n        animation[i].distance.forEach((value, index, array)=>{\r\n            vertexes[index].d = value\r\n        })\r\n        setInstruction(animation[i].instruction);\r\n        setExecution(animation[i].execution);\r\n        setVertexes(vertexes);\r\n        setEdges(edges);\r\n        ctx.clearRect( 0,0, canvasWidth, canvasHeight );\r\n        edges.forEach((value, index, array)=>{array[index].drawEdge(ctx)});\r\n        vertexes.forEach((value, index, array)=>{array[index].drawVertex(ctx)});\r\n\r\n    }\r\n\r\n    function animate(animation) {\r\n        let index = 0;\r\n        let timer = setInterval(frame, 500)\r\n        function frame() {\r\n            if (index == animation.length) {\r\n                clearInterval(timer)\r\n            } else {\r\n                drawFrame(index,animation)\r\n                //draw()\r\n                index++\r\n            }\r\n        }\r\n    }\r\n\r\n    const containsPoint = (x, y) => {\r\n        let isTarget = null;\r\n        for (let i = 0; i < vertexes.length; i++) {\r\n            const circle = vertexes[i];\r\n            let distance = Math.sqrt(Math.pow((circle.x-x),2)+Math.pow((circle.y-y),2))\r\n            if(distance < circle.radius*3/2) {\r\n                dragTarget = circle;\r\n                for(let j = 0; j < edges.length; j++) {\r\n                    if(edges[j].v1 == dragTarget.num)\r\n                        dragEdge.push({num: j, v: 1});\r\n                    if(edges[j].v2 == dragTarget.num)\r\n                        dragEdge.push({num: j, v: 2});\r\n                }\r\n                isTarget = true;\r\n                break;\r\n            }\r\n        }\r\n        return isTarget;\r\n    }\r\n\r\n    const handleCanvasClick=(event)=>{\r\n        const X = Math.random()*(randX)+100;\r\n        const Y = Math.random()*(randY)+100;\r\n        const newVertex = new Vertex(X,Y,COLOR.PINK,vertexes.length)\r\n        vertexes.push(newVertex);\r\n        draw();\r\n    };\r\n\r\n    const handleMouseMove = (event)=>{\r\n        if (!isDown) return;\r\n        const mouseX = parseInt(event.nativeEvent.offsetX - canvas.current.clientLeft);\r\n        const mouseY = parseInt(event.nativeEvent.offsetY - canvas.current.clientTop);\r\n        const dx = mouseX - startX;\r\n        const dy = mouseY - startY;\r\n        startX = mouseX;\r\n        startY = mouseY;\r\n        dragTarget.x += dx;\r\n        dragTarget.y += dy;\r\n        if(dragEdge.length != 0){\r\n            for(let i = 0; i < dragEdge.length; i++) {\r\n                if (dragEdge[i].v == 1) {\r\n                    edges[dragEdge[i].num].x1 += dx;\r\n                    edges[dragEdge[i].num].y1 += dy;\r\n                }\r\n                if (dragEdge[i].v == 2) {\r\n                    edges[dragEdge[i].num].x2 += dx;\r\n                    edges[dragEdge[i].num].y2 += dy;\r\n                }\r\n            }\r\n        }\r\n        draw();\r\n    };\r\n\r\n    const handleMouseDown = (event)=>{\r\n        startX = parseInt(event.nativeEvent.offsetX - canvas.current.clientLeft);\r\n        startY = parseInt(event.nativeEvent.offsetY - canvas.current.clientTop);\r\n        isDown = containsPoint(startX,startY)\r\n    };\r\n\r\n    const handleMouseUp = e => {\r\n        dragTarget = null;\r\n        dragEdge = [];\r\n        isDown = false;\r\n    }\r\n    const handleMouseOut = e => {\r\n        handleMouseUp(e);\r\n    }\r\n\r\n    const handleClearCanvas=(event)=>{\r\n        setVertexes([]);\r\n        setEdges([]);\r\n        setExecution(\" \");\r\n        setInstruction(\" \");\r\n    };\r\n\r\n    const inputChange1=(event)=>{\r\n        edge.vertexe1 = event.target.value;\r\n    };\r\n    const inputChange2=(event)=>{\r\n        edge.vertexe2 = event.target.value;\r\n    };\r\n    const inputChange3=(event)=>{\r\n        edge.weight = event.target.value;\r\n    };\r\n    const inputChange4=(event)=>{\r\n        count = event.target.value;\r\n    };\r\n    const inputSourcePoint=(event)=>{\r\n        sourcePoint = event.target.value;\r\n    };\r\n    const sliderChange=(event)=>{\r\n        if(animation.length > 0) {\r\n            event.target.max = animation.length - 1;\r\n            drawFrame(event.target.value,animation);\r\n        }\r\n    };\r\n    const handleGraphClick = (event)=>{\r\n        for(let i = 0; i < count; i++) {\r\n            vertexes.push(new Vertex(Math.random()*(randX)+100,Math.random()*(randY)+100,COLOR.PINK,vertexes.length))\r\n        }\r\n        let connected = 0\r\n        while(!connected) {\r\n            let flag = 1\r\n            for(let j = 0; j < Math.floor(Math.random()*(vertexes.length*5)); j++) {\r\n                let v1 = Math.floor(Math.random()*vertexes.length)\r\n                let v2 = Math.floor(Math.random()*vertexes.length)\r\n                let weight = Math.floor(Math.random()*100+1)\r\n                for(let k = 0; k < edges.length; k++) {\r\n                    if ((edges[k].v1 == v1 || edges[k].v1 == v2)\r\n                        && (edges[k].v2 == v1 || edges[k].v2 == v2)) {\r\n                        flag = 0\r\n                        break\r\n                    }\r\n                }\r\n                if(!(v1 == v2) && flag){\r\n                    edges.push(new Edge(vertexes[v1], vertexes[v2], weight, COLOR.GREY))\r\n                }\r\n            }\r\n            let graph = new Graph(vertexes.length)\r\n            graph.insert(edges)\r\n            connected = dfs(0,graph.visited,graph.mat,graph.n)\r\n        }\r\n        draw()\r\n    }\r\n    const handleEdgeClick = (event)=>{\r\n        let v1 = edge.vertexe1;\r\n        let v2 = edge.vertexe2;\r\n        let weight = edge.weight;\r\n        edges.push(new Edge(vertexes[v1], vertexes[v2], weight, COLOR.GREY))\r\n        draw();\r\n    };\r\n    function kEdge() {\r\n        this.begin = 0\r\n        this.end = 0\r\n        this.weight = 0\r\n    }\r\n    function find(parent, n) {\r\n        while(parent[n] > 0) {\r\n            n = parent[n]\r\n        }\r\n        return n\r\n    }\r\n    let getEdge = function (v1,v2,edges) {\r\n        let num\r\n        edges.forEach((value, index, array)=>{\r\n            if((array[index].v1 == v1 || array[index].v1 == v2)\r\n                && (array[index].v2 == v1 || array[index].v2 == v2)) {\r\n                num = index\r\n            }\r\n        })\r\n        return num\r\n    }\r\n\r\n    const dfs_ = ()=>{\r\n        let frame\r\n        let execution = \"<br>\"\r\n        let instruction = \" \"\r\n        let v = sourcePoint\r\n        let graph = new Graph(vertexes.length)\r\n        let stack = []\r\n        let result = []\r\n/*        if(v < 0 || v >= vertexCount || isNaN(v)) {\r\n            alert(\"Vertex does not exist\")\r\n            return\r\n        }\r\n        if(graph.n == 0) {\r\n            alert(\"Graph does not exist\")\r\n            return\r\n        }\r\n        disableButtons()*/\r\n        animation.push(new Frame(vertexes.length,edges.length))\r\n        let vertexesColor = new Array(vertexes.length)\r\n        let edgesColor = new Array(edges.length)\r\n        for(let i = 0; i < vertexes.length; i++) {\r\n            vertexesColor[i] = COLOR.PINK\r\n        }\r\n        for(let i = 0; i < edges.length; i++) {\r\n            edgesColor[i] = COLOR.GREY\r\n        }\r\n        graph.insert(edges)\r\n        stack.push(v)\r\n        result.push(v)\r\n        graph.visited[v] = 1\r\n        vertexesColor[v] = COLOR.GREEN\r\n        frame = new Frame(vertexes.length,edges.length)\r\n        frame.record(vertexesColor,edgesColor,instruction,execution)\r\n        animation.push(frame)\r\n\r\n        while(stack.length != 0) {\r\n            let top = stack[stack.length-1]\r\n            let flag = 0\r\n            for(let i = 0; i < graph.n; i++) {\r\n                if(!graph.visited[i] && graph.mat[top][i]!=INF) {\r\n                    stack.push(i)\r\n                    instruction = \"stack | \"+stack.join(\" | \")\r\n                    top = stack[stack.length-1]\r\n                    graph.visited[i] = 1\r\n                    result.push(i)\r\n                    execution += i+\" is not visited, \"+\"visit \"+i+\"<br><br>\"\r\n                    vertexesColor[i] = COLOR.GREEN\r\n                    frame = new Frame(vertexes.length,edges.length)\r\n                    frame.record(vertexesColor,edgesColor,instruction,execution)\r\n                    animation.push(frame)\r\n                    break\r\n                }\r\n            }\r\n            let topColor = vertexesColor[top]\r\n            vertexesColor[top] = COLOR.RED\r\n            execution += \"visit the adjacent vertexes of \"+top+\"<br>\"\r\n            for(let i = 0; i < graph.n; i++) {\r\n                if((graph.mat[top][i]<INF && graph.visited[i])||graph.mat[top][i]==INF) {\r\n                    flag++\r\n                }\r\n                if(graph.mat[top][i]<INF && graph.visited[i]) {\r\n                    execution += i+\" is visited<br>\"\r\n                    let color = vertexesColor[i]\r\n                    vertexesColor[i] = COLOR.RED\r\n                    edgesColor[getEdge(top,i,edges)] = COLOR.RED\r\n                    frame = new Frame(vertexes.length,edges.length)\r\n                    frame.record(vertexesColor,edgesColor,instruction,execution)\r\n                    animation.push(frame)\r\n\r\n                    vertexesColor[i] = color\r\n                    edgesColor[getEdge(top,i,edges)] = COLOR.GREY\r\n                    frame = new Frame(vertexes.length,edges.length)\r\n                    frame.record(vertexesColor,edgesColor,instruction,execution)\r\n                    animation.push(frame)\r\n                }\r\n            }\r\n            vertexesColor[top] = topColor\r\n            frame = new Frame(vertexes.length,edges.length)\r\n            frame.record(vertexesColor,edgesColor,instruction,execution)\r\n            animation.push(frame)\r\n            if(flag == graph.n) {\r\n                stack.pop()\r\n                instruction = \"stack | \"+stack.join(\" | \")\r\n                execution += \"All of the adjacent vertexes of \"+top+\" are visited<br><br>\"\r\n                if(stack.length!=0) top = stack[stack.length-1]\r\n            }\r\n        }\r\n        instruction = \"visit order: \"+result.join(\" \")\r\n        frame = new Frame(vertexes.length,edges.length)\r\n        frame.record(vertexesColor,edgesColor,instruction,execution)\r\n        animation.push(frame)\r\n        animate(animation);\r\n    }\r\n\r\n    return (\r\n        <Layout>\r\n            <Row>\r\n                <Col md={7}>\r\n                    <ButtonGroup aria-label=\"Basic example\">\r\n                        <Button variant=\"secondary\" onClick={handleClearCanvas}>CLEAR</Button>\r\n                        <Button variant=\"secondary\" onClick={handleCanvasClick}>VERTEX</Button>\r\n                        <DropdownButton as={ButtonGroup} title=\"EDGE\" variant=\"secondary\">\r\n                            <input placeholder=\"vertex1\" onChange={inputChange1}/>\r\n                            <input placeholder=\"vertex2\" onChange={inputChange2}/>\r\n                            <input placeholder=\"weight\" onChange={inputChange3}/>\r\n                            <Dropdown.Item onClick={handleEdgeClick}>GENERATE</Dropdown.Item>\r\n                        </DropdownButton>\r\n                        <DropdownButton as={ButtonGroup} title=\"GRAPH\" variant=\"secondary\">\r\n                            <input placeholder=\"count\" onChange={inputChange4}/>\r\n                            <Dropdown.Item onClick={handleGraphClick}>GENERATE</Dropdown.Item>\r\n                        </DropdownButton>\r\n                        <DropdownButton as={ButtonGroup} title=\"ANIMATION\" variant=\"secondary\">\r\n                            <input placeholder=\"vertex1\" onChange={inputSourcePoint}/>\r\n                            <Dropdown.Item onClick={dfs_}>START</Dropdown.Item>\r\n                        </DropdownButton>\r\n                    </ButtonGroup>\r\n                    <div>\r\n                        <canvas\r\n                            className=\"App-canvas\"\r\n                            ref={canvas}\r\n                            width={canvasWidth}\r\n                            height={canvasHeight}\r\n                            onMouseDown={handleMouseDown}\r\n                            onMouseMove={handleMouseMove}\r\n                            onMouseUp={handleMouseUp}\r\n                            onMouseOut={handleMouseOut}/>\r\n                        <div className=\"text-center\">\r\n                            <input type=\"range\" min={0} defaultValue={0} className=\"p-3 slider\" id=\"slider\" onInput={sliderChange}/>\r\n                        </div>\r\n                    </div>\r\n                    <div id=\"instruction\" dangerouslySetInnerHTML={{__html:instruction}}></div>\r\n                    <div id=\"execution\" dangerouslySetInnerHTML={{__html:execution}}></div>\r\n                </Col>\r\n                <Col md={5}>\r\n                    <div className=\"bg-secondary bg-opacity-25\">\r\n                        <h3 className=\"text-secondary p-3\">Depth-first search</h3>\r\n                    </div>\r\n                    <div id=\"code\">\r\n                        <pre>\r\n    {`\r\nfunction dfs(v,graph) {\r\n    let stack = []\r\n    stack.push(v)\r\n    graph.visited[v] = 1\r\n    while(stack.length != 0) {\r\n        let top = stack[stack.length-1]\r\n        let flag = 0\r\n        for(let i = 0; i < graph.n; i++) {\r\n            if((graph.mat[top][i] < Infinity && graph.visited[i]) || graph.mat[top][i] == Infinity) {\r\n                flag++\r\n            }\r\n        }\r\n        if(flag == graph.n) {\r\n            stack.pop()\r\n            if(stack.length!=0) top = stack[stack.length-1]\r\n        }\r\n        for(let i = 0; i < graph.n; i++) {\r\n            if(!graph.visited[i] && graph.mat[top][i] != Infinity) {\r\n                stack.push(i)\r\n                graph.visited[i] = 1\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\n    `}\r\n</pre>\r\n                    </div>\r\n                </Col>\r\n            </Row>\r\n\r\n        </Layout>\r\n    )\r\n}\r\n\r\nexport default DFS;","import React, {useEffect, useRef, useState} from \"react\";\r\nimport {Vertex} from \"../components/Vertex\";\r\nimport {Edge} from \"../components/Edge\";\r\nimport {Frame} from \"../components/Frame\";\r\nimport {Graph} from \"../components/Graph\";\r\nimport {COLOR} from \"../components/Vertex\";\r\nimport {INF} from \"../components/Vertex\";\r\nimport {Layout} from \"../components/Layout\";\r\nimport {ButtonGroup, Button, Dropdown, DropdownButton, Container,Row,Col} from \"react-bootstrap\";\r\nimport {dfs} from \"../components/utils\";\r\n\r\nexport const canvasWidth = 600;\r\nexport const canvasHeight = 300;\r\n\r\nconst Prim = () => {\r\n    const [instruction, setInstruction] = useState(\" \");\r\n    const [execution, setExecution] = useState(\" \");\r\n    const [vertexes, setVertexes] = useState([]);\r\n    const [edges, setEdges] = useState([]);\r\n    const [animation,setAnimation] = useState([]);\r\n    let sourcePoint = 0;\r\n    let count = 0;\r\n    let isDown = false;\r\n    let dragTarget = null;\r\n    let dragEdge = [];\r\n    let startX = null;\r\n    let startY = null;\r\n    let ctx = null;\r\n    /*let vertexes = [];\r\n    let edges = [];*/\r\n    let randX = canvasWidth - 200\r\n    let randY = canvasHeight - 200\r\n    const canvas = useRef(null);\r\n    let edge = {vertexe1:null, vertexe2:null, weight:null}\r\n\r\n    useEffect(()=>{\r\n        const canvasEle = canvas.current;\r\n        canvasEle.width = canvasWidth;\r\n        canvasEle.height = canvasHeight;\r\n\r\n        // get context of the canvas\r\n        ctx = canvasEle.getContext(\"2d\");\r\n        ctx.clearRect( 0,0, canvasWidth, canvasHeight );\r\n        edges.forEach((value, index, array)=>{array[index].drawEdge(ctx)});\r\n        vertexes.forEach((value, index, array)=>{array[index].drawVertex(ctx)});\r\n\r\n    });\r\n\r\n    /*    useEffect(() => {\r\n            draw();\r\n        }, []);*/\r\n\r\n    const draw = () => {\r\n        ctx.clearRect( 0,0, canvasWidth, canvasHeight );\r\n        edges.forEach((value, index, array)=>{array[index].drawEdge(ctx)});\r\n        vertexes.forEach((value, index, array)=>{array[index].drawVertex(ctx)});\r\n\r\n    }\r\n    let drawFrame = function (i,animation) {\r\n        animation[i].edgesColor.forEach((value, index, array)=>{\r\n            edges[index].color = value\r\n        })\r\n        animation[i].vertexesColor.forEach((value, index, array)=>{\r\n            vertexes[index].color = value\r\n        })\r\n        animation[i].distance.forEach((value, index, array)=>{\r\n            vertexes[index].d = value\r\n        })\r\n        setInstruction(animation[i].instruction);\r\n        setExecution(animation[i].execution);\r\n        setVertexes(vertexes);\r\n        setEdges(edges);\r\n        ctx.clearRect( 0,0, canvasWidth, canvasHeight );\r\n        edges.forEach((value, index, array)=>{array[index].drawEdge(ctx)});\r\n        vertexes.forEach((value, index, array)=>{array[index].drawVertex(ctx)});\r\n\r\n    }\r\n\r\n    function animate(animation) {\r\n        let index = 0;\r\n        let timer = setInterval(frame, 500)\r\n        function frame() {\r\n            if (index == animation.length) {\r\n                clearInterval(timer)\r\n            } else {\r\n                drawFrame(index,animation)\r\n                //draw()\r\n                index++\r\n            }\r\n        }\r\n    }\r\n\r\n    const containsPoint = (x, y) => {\r\n        let isTarget = null;\r\n        for (let i = 0; i < vertexes.length; i++) {\r\n            const circle = vertexes[i];\r\n            let distance = Math.sqrt(Math.pow((circle.x-x),2)+Math.pow((circle.y-y),2))\r\n            if(distance < circle.radius*3/2) {\r\n                dragTarget = circle;\r\n                for(let j = 0; j < edges.length; j++) {\r\n                    if(edges[j].v1 == dragTarget.num)\r\n                        dragEdge.push({num: j, v: 1});\r\n                    if(edges[j].v2 == dragTarget.num)\r\n                        dragEdge.push({num: j, v: 2});\r\n                }\r\n                isTarget = true;\r\n                break;\r\n            }\r\n        }\r\n        return isTarget;\r\n    }\r\n\r\n    const handleCanvasClick=(event)=>{\r\n        const X = Math.random()*(randX)+100;\r\n        const Y = Math.random()*(randY)+100;\r\n        const newVertex = new Vertex(X,Y,COLOR.PINK,vertexes.length)\r\n        vertexes.push(newVertex);\r\n        draw();\r\n    };\r\n\r\n    const handleMouseMove = (event)=>{\r\n        if (!isDown) return;\r\n        const mouseX = parseInt(event.nativeEvent.offsetX - canvas.current.clientLeft);\r\n        const mouseY = parseInt(event.nativeEvent.offsetY - canvas.current.clientTop);\r\n        const dx = mouseX - startX;\r\n        const dy = mouseY - startY;\r\n        startX = mouseX;\r\n        startY = mouseY;\r\n        dragTarget.x += dx;\r\n        dragTarget.y += dy;\r\n        if(dragEdge.length != 0){\r\n            for(let i = 0; i < dragEdge.length; i++) {\r\n                if (dragEdge[i].v == 1) {\r\n                    edges[dragEdge[i].num].x1 += dx;\r\n                    edges[dragEdge[i].num].y1 += dy;\r\n                }\r\n                if (dragEdge[i].v == 2) {\r\n                    edges[dragEdge[i].num].x2 += dx;\r\n                    edges[dragEdge[i].num].y2 += dy;\r\n                }\r\n            }\r\n        }\r\n        draw();\r\n    };\r\n\r\n    const handleMouseDown = (event)=>{\r\n        startX = parseInt(event.nativeEvent.offsetX - canvas.current.clientLeft);\r\n        startY = parseInt(event.nativeEvent.offsetY - canvas.current.clientTop);\r\n        isDown = containsPoint(startX,startY)\r\n    };\r\n\r\n    const handleMouseUp = e => {\r\n        dragTarget = null;\r\n        dragEdge = [];\r\n        isDown = false;\r\n    }\r\n    const handleMouseOut = e => {\r\n        handleMouseUp(e);\r\n    }\r\n\r\n    const handleClearCanvas=(event)=>{\r\n        setVertexes([]);\r\n        setEdges([]);\r\n        setExecution(\" \");\r\n        setInstruction(\" \");\r\n    };\r\n\r\n    const inputChange1=(event)=>{\r\n        edge.vertexe1 = event.target.value;\r\n    };\r\n    const inputChange2=(event)=>{\r\n        edge.vertexe2 = event.target.value;\r\n    };\r\n    const inputChange3=(event)=>{\r\n        edge.weight = event.target.value;\r\n    };\r\n    const inputChange4=(event)=>{\r\n        count = event.target.value;\r\n    };\r\n    const inputSourcePoint=(event)=>{\r\n        sourcePoint = event.target.value;\r\n    };\r\n    const sliderChange=(event)=>{\r\n        if(animation.length > 0) {\r\n            event.target.max = animation.length - 1;\r\n            drawFrame(event.target.value,animation);\r\n        }\r\n    };\r\n    const handleGraphClick = (event)=>{\r\n        for(let i = 0; i < count; i++) {\r\n            vertexes.push(new Vertex(Math.random()*(randX)+100,Math.random()*(randY)+100,COLOR.PINK,vertexes.length))\r\n        }\r\n        let connected = 0\r\n        while(!connected) {\r\n            let flag = 1\r\n            for(let j = 0; j < Math.floor(Math.random()*(vertexes.length*5)); j++) {\r\n                let v1 = Math.floor(Math.random()*vertexes.length)\r\n                let v2 = Math.floor(Math.random()*vertexes.length)\r\n                let weight = Math.floor(Math.random()*100+1)\r\n                for(let k = 0; k < edges.length; k++) {\r\n                    if ((edges[k].v1 == v1 || edges[k].v1 == v2)\r\n                        && (edges[k].v2 == v1 || edges[k].v2 == v2)) {\r\n                        flag = 0\r\n                        break\r\n                    }\r\n                }\r\n                if(!(v1 == v2) && flag){\r\n                    edges.push(new Edge(vertexes[v1], vertexes[v2], weight, COLOR.GREY))\r\n                }\r\n            }\r\n            let graph = new Graph(vertexes.length)\r\n            graph.insert(edges)\r\n            connected = dfs(0,graph.visited,graph.mat,graph.n)\r\n        }\r\n        draw()\r\n    }\r\n    const handleEdgeClick = (event)=>{\r\n        let v1 = edge.vertexe1;\r\n        let v2 = edge.vertexe2;\r\n        let weight = edge.weight;\r\n        edges.push(new Edge(vertexes[v1], vertexes[v2], weight, COLOR.GREY))\r\n        draw();\r\n    };\r\n    function kEdge() {\r\n        this.begin = 0\r\n        this.end = 0\r\n        this.weight = 0\r\n    }\r\n    function find(parent, n) {\r\n        while(parent[n] > 0) {\r\n            n = parent[n]\r\n        }\r\n        return n\r\n    }\r\n    let getEdge = function (v1,v2,edges) {\r\n        let num\r\n        edges.forEach((value, index, array)=>{\r\n            if((array[index].v1 == v1 || array[index].v1 == v2)\r\n                && (array[index].v2 == v1 || array[index].v2 == v2)) {\r\n                num = index\r\n            }\r\n        })\r\n        return num\r\n    }\r\n\r\n    const prim = ()=>{\r\n        let frame\r\n        let execution = \"<br>\"\r\n        let instruction = \" \"\r\n        let minEdges = new Array(vertexes.length)\r\n        let v = sourcePoint\r\n        let graph = new Graph(vertexes.length)\r\n        let vertexesColor = new Array(vertexes.length)\r\n        let edgesColor = new Array(edges.length)\r\n        for(let i = 0; i < vertexes.length; i++) {\r\n            vertexesColor[i] = COLOR.PINK\r\n        }\r\n        for(let i = 0; i < edges.length; i++) {\r\n            edgesColor[i] = COLOR.GREY\r\n        }\r\n        graph.insert(edges)\r\n/*        if(v<0 || v>=vertexCount || isNaN(v)) {\r\n            alert(\"Vertex does not exist\")\r\n            return\r\n        }\r\n        if(graph.n == 0) {\r\n            alert(\"Graph does not exist\")\r\n            return\r\n        }\r\n        let connected = utils.dfs(v,graph.visited,graph.mat,graph.n)\r\n        if(!connected) {\r\n            alert(\"Graph is not connected\")\r\n            return\r\n        }\r\n        disableButtons()*/\r\n        animation.push(new Frame(vertexes.length,edges.length))\r\n        for(let i = 0; i < graph.n; i++) {\r\n            graph.visited[i] = 0\r\n        }\r\n        let result = []\r\n        graph.dist[v] = 0\r\n        for(let i = 0; i < graph.n; i++) {\r\n            let minDist = INF\r\n            let minVertex\r\n            for(let j = 0; j < graph.n; j++) {\r\n                if(!graph.visited[j] && (graph.dist[j] < minDist)) {\r\n                    minDist = graph.dist[j]\r\n                    minVertex = j\r\n                }\r\n            }\r\n            graph.visited[minVertex] = 1\r\n            result.push(minVertex)\r\n            instruction = \"Vertexes: \"+result.join(\" \")\r\n\r\n            frame = new Frame(vertexes.length,edges.length)\r\n            vertexesColor[minVertex] = COLOR.GREEN\r\n            edgesColor[getEdge(minVertex,minEdges[minVertex],edges)] = COLOR.GREEN\r\n            execution += \"Adding \"+minVertex+\" to the tree<br>\"\r\n            frame.record(vertexesColor,edgesColor,instruction,execution)\r\n            animation.push(frame)\r\n\r\n            execution += \"<br>Finding the minimum edge<br>\"\r\n            for(let j = 0; j < result.length; j++) {\r\n                for(let k = 0; k < graph.n; k++) {\r\n                    if(graph.mat[result[j]][k]!=INF && !graph.visited[k]){\r\n\r\n                        frame = new Frame(vertexes.length,edges.length)\r\n                        vertexesColor[k] = COLOR.YELLOW\r\n                        edgesColor[getEdge(result[j],k,edges)] = COLOR.YELLOW\r\n                        frame.record(vertexesColor,edgesColor,instruction,execution)\r\n                        animation.push(frame)\r\n\r\n                        frame = new Frame(vertexes.length,edges.length)\r\n                        vertexesColor[k] = COLOR.PINK\r\n                        edgesColor[getEdge(result[j],k,edges)] = COLOR.GREY\r\n                        frame.record(vertexesColor,edgesColor,instruction,execution)\r\n                        animation.push(frame)\r\n                    }\r\n                }\r\n            }\r\n            for(let j = 0; j < graph.n; j++) {\r\n                if(!graph.visited[j] && (graph.mat[minVertex][j] < graph.dist[j])) {\r\n                    graph.dist[j] = graph.mat[minVertex][j]\r\n                    minEdges[j] = minVertex\r\n                }\r\n            }\r\n        }\r\n        animate(animation);\r\n    }\r\n\r\n    return (\r\n        <Layout>\r\n            <Row>\r\n                <Col md={7}>\r\n                    <ButtonGroup aria-label=\"Basic example\">\r\n                        <Button variant=\"secondary\" onClick={handleClearCanvas}>CLEAR</Button>\r\n                        <Button variant=\"secondary\" onClick={handleCanvasClick}>VERTEX</Button>\r\n                        <DropdownButton as={ButtonGroup} title=\"EDGE\" variant=\"secondary\">\r\n                            <input placeholder=\"vertex1\" onChange={inputChange1}/>\r\n                            <input placeholder=\"vertex2\" onChange={inputChange2}/>\r\n                            <input placeholder=\"weight\" onChange={inputChange3}/>\r\n                            <Dropdown.Item onClick={handleEdgeClick}>GENERATE</Dropdown.Item>\r\n                        </DropdownButton>\r\n                        <DropdownButton as={ButtonGroup} title=\"GRAPH\" variant=\"secondary\">\r\n                            <input placeholder=\"count\" onChange={inputChange4}/>\r\n                            <Dropdown.Item onClick={handleGraphClick}>GENERATE</Dropdown.Item>\r\n                        </DropdownButton>\r\n                        <DropdownButton as={ButtonGroup} title=\"ANIMATION\" variant=\"secondary\">\r\n                            <input placeholder=\"vertex1\" onChange={inputSourcePoint}/>\r\n                            <Dropdown.Item onClick={prim}>START</Dropdown.Item>\r\n                        </DropdownButton>\r\n                    </ButtonGroup>\r\n                    <div>\r\n                        <canvas\r\n                            className=\"App-canvas\"\r\n                            ref={canvas}\r\n                            width={canvasWidth}\r\n                            height={canvasHeight}\r\n                            onMouseDown={handleMouseDown}\r\n                            onMouseMove={handleMouseMove}\r\n                            onMouseUp={handleMouseUp}\r\n                            onMouseOut={handleMouseOut}/>\r\n                        <div className=\"text-center\">\r\n                            <input type=\"range\" min={0} defaultValue={0} className=\"p-3 slider\" id=\"slider\" onInput={sliderChange}/>\r\n                        </div>\r\n                    </div>\r\n                    <div id=\"instruction\" dangerouslySetInnerHTML={{__html:instruction}}></div>\r\n                    <div id=\"execution\" dangerouslySetInnerHTML={{__html:execution}}></div>\r\n                </Col>\r\n                <Col md={5}>\r\n                    <div className=\"bg-secondary bg-opacity-25\">\r\n                        <h3 className=\"text-secondary p-3\">Prim's algorithm</h3>\r\n                    </div>\r\n                    <div id=\"code\">\r\n                        <pre>\r\n    {`\r\nfunction prim(v,graph) {\r\n    let minEdges = new Array(graph.n)\r\n    graph.dist[v] = 0\r\n    for(let i = 0; i < graph.n; i++) {\r\n        let minDist = INF\r\n        let minVertex\r\n        for(let j = 0; j < graph.n; j++) {\r\n            if(!graph.visited[j] && (graph.dist[j] < minDist)) {\r\n                minDist = graph.dist[j]\r\n                minVertex = j\r\n            }\r\n        }\r\n        graph.visited[minVertex] = 1\r\n        for(let j = 0; j < graph.n; j++) {\r\n            if(!graph.visited[j] && (graph.mat[minVertex][j] < graph.dist[j])) {\r\n                graph.dist[j] = graph.mat[minVertex][j]\r\n                minEdges[j] = minVertex\r\n            }\r\n        }\r\n    }\r\n}\r\n    `}\r\n</pre>\r\n                    </div>\r\n                </Col>\r\n            </Row>\r\n\r\n        </Layout>\r\n    )\r\n}\r\n\r\nexport default Prim;\r\n","import React, {useEffect, useRef, useState} from \"react\";\r\nimport {Vertex} from \"../components/Vertex\";\r\nimport {Edge} from \"../components/Edge\";\r\nimport {Frame} from \"../components/Frame\";\r\nimport {Graph} from \"../components/Graph\";\r\nimport {COLOR} from \"../components/Vertex\";\r\nimport {INF} from \"../components/Vertex\";\r\nimport {Layout} from \"../components/Layout\";\r\nimport {ButtonGroup, Button, Dropdown, DropdownButton, Container,Row,Col} from \"react-bootstrap\";\r\nimport {dfs} from \"../components/utils\";\r\n\r\nexport const canvasWidth = 600;\r\nexport const canvasHeight = 300;\r\n\r\nconst Dijkstra = () => {\r\n    const [instruction, setInstruction] = useState(\" \");\r\n    const [execution, setExecution] = useState(\" \");\r\n    const [vertexes, setVertexes] = useState([]);\r\n    const [edges, setEdges] = useState([]);\r\n    const [animation,setAnimation] = useState([]);\r\n    let sourcePoint = 0;\r\n    let count = 0;\r\n    let isDown = false;\r\n    let dragTarget = null;\r\n    let dragEdge = [];\r\n    let startX = null;\r\n    let startY = null;\r\n    let ctx = null;\r\n    /*let vertexes = [];\r\n    let edges = [];*/\r\n    let randX = canvasWidth - 200\r\n    let randY = canvasHeight - 200\r\n    const canvas = useRef(null);\r\n    let edge = {vertexe1:null, vertexe2:null, weight:null}\r\n\r\n    useEffect(()=>{\r\n        const canvasEle = canvas.current;\r\n        canvasEle.width = canvasWidth;\r\n        canvasEle.height = canvasHeight;\r\n\r\n        // get context of the canvas\r\n        ctx = canvasEle.getContext(\"2d\");\r\n        ctx.clearRect( 0,0, canvasWidth, canvasHeight );\r\n        edges.forEach((value, index, array)=>{array[index].drawEdge(ctx)});\r\n        vertexes.forEach((value, index, array)=>{array[index].drawVertex(ctx)});\r\n\r\n    });\r\n\r\n    /*    useEffect(() => {\r\n            draw();\r\n        }, []);*/\r\n\r\n    const draw = () => {\r\n        ctx.clearRect( 0,0, canvasWidth, canvasHeight );\r\n        edges.forEach((value, index, array)=>{array[index].drawEdge(ctx)});\r\n        vertexes.forEach((value, index, array)=>{array[index].drawVertex(ctx)});\r\n\r\n    }\r\n    let drawFrame = function (i,animation) {\r\n        animation[i].edgesColor.forEach((value, index, array)=>{\r\n            edges[index].color = value\r\n        })\r\n        animation[i].vertexesColor.forEach((value, index, array)=>{\r\n            vertexes[index].color = value\r\n        })\r\n        animation[i].distance.forEach((value, index, array)=>{\r\n            vertexes[index].d = value\r\n        })\r\n        setInstruction(animation[i].instruction);\r\n        setExecution(animation[i].execution);\r\n        setVertexes(vertexes);\r\n        setEdges(edges);\r\n        ctx.clearRect( 0,0, canvasWidth, canvasHeight );\r\n        edges.forEach((value, index, array)=>{array[index].drawEdge(ctx)});\r\n        vertexes.forEach((value, index, array)=>{array[index].drawVertex(ctx)});\r\n\r\n    }\r\n\r\n    function animate(animation) {\r\n        let index = 0;\r\n        let timer = setInterval(frame, 500)\r\n        function frame() {\r\n            if (index == animation.length) {\r\n                clearInterval(timer)\r\n            } else {\r\n                drawFrame(index,animation)\r\n                //draw()\r\n                index++\r\n            }\r\n        }\r\n    }\r\n\r\n    const containsPoint = (x, y) => {\r\n        let isTarget = null;\r\n        for (let i = 0; i < vertexes.length; i++) {\r\n            const circle = vertexes[i];\r\n            let distance = Math.sqrt(Math.pow((circle.x-x),2)+Math.pow((circle.y-y),2))\r\n            if(distance < circle.radius*3/2) {\r\n                dragTarget = circle;\r\n                for(let j = 0; j < edges.length; j++) {\r\n                    if(edges[j].v1 == dragTarget.num)\r\n                        dragEdge.push({num: j, v: 1});\r\n                    if(edges[j].v2 == dragTarget.num)\r\n                        dragEdge.push({num: j, v: 2});\r\n                }\r\n                isTarget = true;\r\n                break;\r\n            }\r\n        }\r\n        return isTarget;\r\n    }\r\n\r\n    const handleCanvasClick=(event)=>{\r\n        const X = Math.random()*(randX)+100;\r\n        const Y = Math.random()*(randY)+100;\r\n        const newVertex = new Vertex(X,Y,COLOR.PINK,vertexes.length)\r\n        vertexes.push(newVertex);\r\n        draw();\r\n    };\r\n\r\n    const handleMouseMove = (event)=>{\r\n        if (!isDown) return;\r\n        const mouseX = parseInt(event.nativeEvent.offsetX - canvas.current.clientLeft);\r\n        const mouseY = parseInt(event.nativeEvent.offsetY - canvas.current.clientTop);\r\n        const dx = mouseX - startX;\r\n        const dy = mouseY - startY;\r\n        startX = mouseX;\r\n        startY = mouseY;\r\n        dragTarget.x += dx;\r\n        dragTarget.y += dy;\r\n        if(dragEdge.length != 0){\r\n            for(let i = 0; i < dragEdge.length; i++) {\r\n                if (dragEdge[i].v == 1) {\r\n                    edges[dragEdge[i].num].x1 += dx;\r\n                    edges[dragEdge[i].num].y1 += dy;\r\n                }\r\n                if (dragEdge[i].v == 2) {\r\n                    edges[dragEdge[i].num].x2 += dx;\r\n                    edges[dragEdge[i].num].y2 += dy;\r\n                }\r\n            }\r\n        }\r\n        draw();\r\n    };\r\n\r\n    const handleMouseDown = (event)=>{\r\n        startX = parseInt(event.nativeEvent.offsetX - canvas.current.clientLeft);\r\n        startY = parseInt(event.nativeEvent.offsetY - canvas.current.clientTop);\r\n        isDown = containsPoint(startX,startY)\r\n    };\r\n\r\n    const handleMouseUp = e => {\r\n        dragTarget = null;\r\n        dragEdge = [];\r\n        isDown = false;\r\n    }\r\n    const handleMouseOut = e => {\r\n        handleMouseUp(e);\r\n    }\r\n\r\n    const handleClearCanvas=(event)=>{\r\n        setVertexes([]);\r\n        setEdges([]);\r\n        setExecution(\" \");\r\n        setInstruction(\" \");\r\n    };\r\n\r\n    const inputChange1=(event)=>{\r\n        edge.vertexe1 = event.target.value;\r\n    };\r\n    const inputChange2=(event)=>{\r\n        edge.vertexe2 = event.target.value;\r\n    };\r\n    const inputChange3=(event)=>{\r\n        edge.weight = event.target.value;\r\n    };\r\n    const inputChange4=(event)=>{\r\n        count = event.target.value;\r\n    };\r\n    const inputSourcePoint=(event)=>{\r\n        sourcePoint = event.target.value;\r\n    };\r\n    const sliderChange=(event)=>{\r\n        if(animation.length > 0) {\r\n            event.target.max = animation.length - 1;\r\n            drawFrame(event.target.value,animation);\r\n        }\r\n    };\r\n    const handleGraphClick = (event)=>{\r\n        for(let i = 0; i < count; i++) {\r\n            vertexes.push(new Vertex(Math.random()*(randX)+100,Math.random()*(randY)+100,COLOR.PINK,vertexes.length))\r\n        }\r\n        let connected = 0\r\n        while(!connected) {\r\n            let flag = 1\r\n            for(let j = 0; j < Math.floor(Math.random()*(vertexes.length*5)); j++) {\r\n                let v1 = Math.floor(Math.random()*vertexes.length)\r\n                let v2 = Math.floor(Math.random()*vertexes.length)\r\n                let weight = Math.floor(Math.random()*100+1)\r\n                for(let k = 0; k < edges.length; k++) {\r\n                    if ((edges[k].v1 == v1 || edges[k].v1 == v2)\r\n                        && (edges[k].v2 == v1 || edges[k].v2 == v2)) {\r\n                        flag = 0\r\n                        break\r\n                    }\r\n                }\r\n                if(!(v1 == v2) && flag){\r\n                    edges.push(new Edge(vertexes[v1], vertexes[v2], weight, COLOR.GREY))\r\n                }\r\n            }\r\n            let graph = new Graph(vertexes.length)\r\n            graph.insert(edges)\r\n            connected = dfs(0,graph.visited,graph.mat,graph.n)\r\n        }\r\n        draw()\r\n    }\r\n    const handleEdgeClick = (event)=>{\r\n        let v1 = edge.vertexe1;\r\n        let v2 = edge.vertexe2;\r\n        let weight = edge.weight;\r\n        edges.push(new Edge(vertexes[v1], vertexes[v2], weight, COLOR.GREY))\r\n        draw();\r\n    };\r\n    function kEdge() {\r\n        this.begin = 0\r\n        this.end = 0\r\n        this.weight = 0\r\n    }\r\n    function find(parent, n) {\r\n        while(parent[n] > 0) {\r\n            n = parent[n]\r\n        }\r\n        return n\r\n    }\r\n    let getEdge = function (v1,v2,edges) {\r\n        let num\r\n        edges.forEach((value, index, array)=>{\r\n            if((array[index].v1 == v1 || array[index].v1 == v2)\r\n                && (array[index].v2 == v1 || array[index].v2 == v2)) {\r\n                num = index\r\n            }\r\n        })\r\n        return num\r\n    }\r\n\r\n    const dijkstra = ()=>{\r\n        let frame\r\n        let execution = \"<br>\"\r\n        let instruction = \"Visited vertexes: \"\r\n        let path = new Array(vertexes.length)\r\n        let v = sourcePoint\r\n        let graph = new Graph(vertexes.length)\r\n        let vertexesColor = new Array(vertexes.length)\r\n        let edgesColor = new Array(edges.length)\r\n        let distance = new Array(vertexes.length)\r\n        for(let i = 0; i < vertexes.length; i++) {\r\n            distance[i] = INF\r\n        }\r\n        for(let i = 0; i < vertexes.length; i++) {\r\n            vertexesColor[i] = COLOR.PINK\r\n        }\r\n        for(let i = 0; i < edges.length; i++) {\r\n            edgesColor[i] = COLOR.GREY\r\n        }\r\n        graph.insert(edges)\r\n/*        if(v< 0 || v >= vertexCount || isNaN(v)) {\r\n            alert(\"Vertex does not exist\")\r\n            return\r\n        }\r\n        if(graph.n == 0) {\r\n            alert(\"Graph does not exist\")\r\n            return\r\n        }\r\n        let connected = utils.dfs(v,graph.visited,graph.mat,graph.n)\r\n        if(!connected) {\r\n            alert(\"Graph is not connected\")\r\n            return\r\n        }\r\n        disableButtons()*/\r\n        for(let i = 0; i < graph.n; i++) {\r\n            graph.visited[i] = 0\r\n        }\r\n        graph.dist[v] = 0\r\n        frame = new Frame(vertexes.length,edges.length)\r\n        frame.recordDistance(distance)\r\n        frame.record(vertexesColor,edgesColor,instruction,execution)\r\n        animation.push(frame)\r\n        distance[v] = 0\r\n        for(let i = 0; i < graph.n; i++) {\r\n            let minDist = INF\r\n            let minVertex\r\n            execution += \"Finding the vertex closest to the source point<br>\"\r\n            for(let j = 0; j < graph.n; j++) {\r\n                if(!graph.visited[j] && (graph.dist[j] < minDist)) {\r\n                    let color = vertexesColor[j]\r\n                    vertexesColor[j] = COLOR.YELLOW\r\n                    frame = new Frame(vertexes.length,edges.length)\r\n                    frame.recordDistance(distance)\r\n                    frame.record(vertexesColor,edgesColor,instruction,execution)\r\n                    animation.push(frame)\r\n                    vertexesColor[j] = color\r\n                    minDist = graph.dist[j]\r\n                    minVertex = j\r\n                }\r\n            }\r\n            instruction += minVertex+\" \"\r\n            graph.visited[minVertex] = 1\r\n            vertexesColor[minVertex] = COLOR.GREEN\r\n            edgesColor[getEdge(minVertex,path[minVertex],edges)] = COLOR.GREEN\r\n            execution += \"Adding \"+minVertex+\" to the vertexes set<br><br>\"\r\n            frame = new Frame(vertexes.length,edges.length)\r\n            frame.recordDistance(distance)\r\n            frame.record(vertexesColor,edgesColor,instruction,execution)\r\n            animation.push(frame)\r\n            for(let j = 0; j < graph.n; j++) {\r\n                if(!graph.visited[j] && (minDist + graph.mat[minVertex][j]) < graph.dist[j]) {\r\n                    graph.dist[j] = minDist + graph.mat[minVertex][j]\r\n                    path[j] = minVertex\r\n                    distance[j] = graph.dist[j]\r\n                    execution += \"The distance from vertex \"+j+\" to source point is updated to \"+graph.dist[j]+\"<br>\"\r\n                    let color = vertexesColor[j]\r\n                    vertexesColor[j] = COLOR.BLUE\r\n                    frame = new Frame(vertexes.length,edges.length)\r\n                    frame.recordDistance(distance)\r\n                    frame.record(vertexesColor,edgesColor,instruction,execution)\r\n                    animation.push(frame)\r\n                    vertexesColor[j] = color\r\n                    frame = new Frame(vertexes.length,edges.length)\r\n                    frame.recordDistance(distance)\r\n                    frame.record(vertexesColor,edgesColor,instruction,execution)\r\n                    animation.push(frame)\r\n                }\r\n            }\r\n            execution += \"<br>\"\r\n        }\r\n        for(let i = 0; i < graph.n; i++) {\r\n            let temp = i\r\n            execution += \"The shortest path from \"+i+\" to \"+v+\" is \"+temp\r\n            while(temp!=v) {\r\n                temp = path[temp]\r\n                execution += \"-->\"+temp\r\n            }\r\n            execution += \"<br>\"\r\n        }\r\n        frame = new Frame(vertexes.length,edges.length)\r\n        frame.recordDistance(distance)\r\n        frame.record(vertexesColor,edgesColor,instruction,execution)\r\n        animation.push(frame)\r\n        animate(animation);\r\n    }\r\n\r\n    return (\r\n        <Layout>\r\n            <Row>\r\n                <Col md={7}>\r\n                    <ButtonGroup aria-label=\"Basic example\">\r\n                        <Button variant=\"secondary\" onClick={handleClearCanvas}>CLEAR</Button>\r\n                        <Button variant=\"secondary\" onClick={handleCanvasClick}>VERTEX</Button>\r\n                        <DropdownButton as={ButtonGroup} title=\"EDGE\" variant=\"secondary\">\r\n                            <input placeholder=\"vertex1\" onChange={inputChange1}/>\r\n                            <input placeholder=\"vertex2\" onChange={inputChange2}/>\r\n                            <input placeholder=\"weight\" onChange={inputChange3}/>\r\n                            <Dropdown.Item onClick={handleEdgeClick}>GENERATE</Dropdown.Item>\r\n                        </DropdownButton>\r\n                        <DropdownButton as={ButtonGroup} title=\"GRAPH\" variant=\"secondary\">\r\n                            <input placeholder=\"count\" onChange={inputChange4}/>\r\n                            <Dropdown.Item onClick={handleGraphClick}>GENERATE</Dropdown.Item>\r\n                        </DropdownButton>\r\n                        <DropdownButton as={ButtonGroup} title=\"ANIMATION\" variant=\"secondary\">\r\n                            <input placeholder=\"vertex1\" onChange={inputSourcePoint}/>\r\n                            <Dropdown.Item onClick={dijkstra}>START</Dropdown.Item>\r\n                        </DropdownButton>\r\n                    </ButtonGroup>\r\n                    <div>\r\n                        <canvas\r\n                            className=\"App-canvas\"\r\n                            ref={canvas}\r\n                            width={canvasWidth}\r\n                            height={canvasHeight}\r\n                            onMouseDown={handleMouseDown}\r\n                            onMouseMove={handleMouseMove}\r\n                            onMouseUp={handleMouseUp}\r\n                            onMouseOut={handleMouseOut}/>\r\n                        <div className=\"text-center\">\r\n                            <input type=\"range\" min={0} defaultValue={0} className=\"p-3 slider\" id=\"slider\" onInput={sliderChange}/>\r\n                        </div>\r\n                    </div>\r\n                    <div id=\"instruction\" dangerouslySetInnerHTML={{__html:instruction}}></div>\r\n                    <div id=\"execution\" dangerouslySetInnerHTML={{__html:execution}}></div>\r\n                </Col>\r\n                <Col md={5}>\r\n                    <div className=\"bg-secondary bg-opacity-25\">\r\n                        <h3 className=\"text-secondary p-3\">Dijkstra's algorithm</h3>\r\n                    </div>\r\n                    <div id=\"code\">\r\n                        <pre>\r\n    {`\r\nfunction Dijkstra(v,graph) {\r\n    graph.dist[v] = 0\r\n    for(let i = 0; i < graph.n; i++) {\r\n        let minDist = Infinity\r\n        let minVertex\r\n        for(let j = 0; j < graph.n; j++) {\r\n            if(!graph.visited[j] && (graph.dist[j] < minDist)) {\r\n                minDist = graph.dist[j]\r\n                minVertex = j\r\n            }\r\n        }\r\n        visited[minVertex] = 1\r\n        for(let j = 0; j < graph.n; j++) {\r\n            if(!graph.visited[j] && (minDist + graph.mat[minVertex][j]) < graph.dist[j]) {\r\n                graph.dist[j] = minDist + graph.mat[minVertex][j]\r\n            }\r\n        }\r\n    }\r\n}\r\n    `}\r\n</pre>\r\n                    </div>\r\n                </Col>\r\n            </Row>\r\n\r\n        </Layout>\r\n    )\r\n}\r\n\r\nexport default Dijkstra;","import React from \"react\";\r\nimport { HashRouter, Routes, Route } from \"react-router-dom\";\r\nimport Kruskal from \"./kruskal\";\r\nimport HomePage from \"./home\";\r\nimport BFS from \"./bfs\";\r\nimport DFS from \"./dfs\";\r\nimport Prim from \"./prim\";\r\nimport Dijkstra from \"./dijkstra\";\r\nconst TheRoutes = () => {\r\n    return (\r\n        <HashRouter>\r\n            <Routes>\r\n                <Route path=\"/\" element={<HomePage/>} />\r\n                <Route path=\"/bfs\" element={<BFS/>}/>\r\n                <Route path=\"/dfs\" element={<DFS/>}/>\r\n                <Route path=\"/kruskal\" element={<Kruskal/>}/>\r\n                <Route path=\"/prim\" element={<Prim/>}/>\r\n                <Route path=\"/dijkstra\" element={<Dijkstra/>}/>\r\n            </Routes>\r\n        </HashRouter>\r\n    );\r\n};\r\n\r\nexport default TheRoutes;","import React from \"react\";\nimport logo from './logo.svg';\nimport './App.css';\nimport 'bootstrap/dist/css/bootstrap.min.css';\nimport TheRoutes from \"./pages/routes\";\nfunction App() {\n  return (\n      <TheRoutes/>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}